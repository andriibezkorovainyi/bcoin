#!/usr/bin/env node

'use strict';

process.title = 'bcoin';

const assert = require('assert');
const SPVNode = require('../lib/node/spvnode');
const util = require('../lib/utils/util');
const Outpoint = require('../lib/primitives/outpoint');
const fs = require('fs');

const node = SPVNode({
  config: true,
  argv: true,
  env: true,
  logFile: true,
  logConsole: true,
  logLevel: 'debug',
  db: 'leveldb',
  persistent: true,
  workers: true,
  listen: true,
  loader: require
});

// Temporary hack
if (!node.has('walletdb')) {
  const plugin = require('../lib/wallet/plugin');
  node.use(plugin);
}

process.on('unhandledRejection', (err, promise) => {
  throw err;
});

(async () => {
  await node.ensure();
  await node.open();
  await node.connect();

  if (node.config.bool('test')) {
    node.pool.watchAddress('1VayNert3x1KzbpzMGt2qdqrAThiRovi8');
    node.pool.watchOutpoint(new Outpoint());
    node.on('block', (block) => {
      assert(block.txs.length >= 1);
      if (block.txs.length > 1)
        util.log(block.txs[1]);
    });
  }

  // attempt to collect coinbase transactions by adding null outpoint to bloom filter
  node.pool.watchOutpoint(new Outpoint());
  node.on('block', (block) => {
     console.log(" ---- new coinbase tx received ----");
     var cbScriptSig = block.txs[0]['inputs'][0]['script'].toJSON();
     // reverse byte order of little endian hash
     var blockHash = block.hash('hex').match(/[a-fA-F0-9]{2}/g).reverse().join('');
     console.log("Block hash: " + blockHash + "\n" + "Coinbase scriptSig: " + cbScriptSig);
     fs.writeFile("/home/pi/.bcoin/spv_cb_" + blockHash, cbScriptSig, function(err){
         if(err)
             return console.log(err);
        console.log("coinbase file saved\n--------");
    });
  });



  node.startSync();
})().catch((err) => {
  console.error(err.stack);
  process.exit(1);
});
